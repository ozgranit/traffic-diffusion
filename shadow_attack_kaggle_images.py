import argparse
import json
import os
import cv2
import pickle
import xml.etree.ElementTree as ET
import matplotlib.pyplot as plt
from collections import Counter
import sys
import numpy as np
import torch
from torchvision import transforms
from ShadowAttack.utils import pre_process_image, draw_shadow, shadow_edge_blur

from ShadowAttack import lisa, gtsrb
from ShadowAttack.pso import PSO
from load_kaggle_images import process_image, plot_triple_images_and_adv, crop_image

sys.path.append('ShadowAttack')
from ShadowAttack.utils import brightness, judge_mask_type, load_mask
from seed import *
# LISA stop sign label is: 12
# GTSRB stop sign label is: 14

parser = argparse.ArgumentParser(description="Adversarial attack by shadow")
parser.add_argument("--shadow_level", type=float, default=0.43,
                    help="shadow coefficient k")
parser.add_argument("--attack_db", type=str, default="LISA",
                    help="the target dataset should be specified for a digital attack")
parser.add_argument("--attack_type", type=str, default="physical",
                    help="digital attack or physical attack")
# parser.add_argument("--image_path", type=str, default="./xxx",
#                     help="a file path to the target image should be specified for a physical attack")
parser.add_argument("--mask_path", type=str, default="octagon_mask.png",
                    help="a file path to the mask should be specified for a physical attack")
# parser.add_argument("--image_label", type=int, default=0,
#                     help="a ground truth should be specified for a physical attack")
parser.add_argument("--polygon", type=int, default=3,
                    help="shadow shape: n-sided polygon")
parser.add_argument("--n_try", type=int, default=5,
                    help="n-random-start strategy: retry n times")
parser.add_argument("--target_model", type=str, default="normal",
                    help="attack normal model or robust model")

args = parser.parse_args()
shadow_level = args.shadow_level
target_model = args.target_model
attack_db = args.attack_db
attack_type = args.attack_type
# image_path = args.image_path
mask_path = args.mask_path
# image_label = args.image_label
polygon = args.polygon
n_try = args.n_try

# def load_params():
with open('ShadowAttack/params.json', 'rb') as f:
    params = json.load(f)
    class_n_gtsrb = params['GTSRB']['class_n']
    class_n_lisa = params['LISA']['class_n']
    device = params['device']
    position_list, mask_list = load_mask()

        # return position_list, mask_list

assert attack_type in ['digital', 'physical']
if attack_type == 'digital':
    particle_size = 10
    iter_num = 100
    x_min, x_max = -16, 48
    max_speed = 1.5
else:
    particle_size = 10
    iter_num = 200
    x_min, x_max = -112, 336
    max_speed = 10.
    n_try = 1

# def load_model(attack_db, class_n_lisa, class_n_gtsrb, device):
assert attack_db in ['LISA', 'GTSRB']
if attack_db == "LISA":
    model = lisa.LisaCNN(n_class=class_n_lisa).to(device)
    model.load_state_dict(
        # torch.load(f'ShadowAttack/model/{"adv_" if target_model == "robust" else ""}model_lisa.pth',
        torch.load(f'ShadowAttack/model/{"adv_" if target_model == "robust" else ""}model_lisa.pth',

                   map_location=torch.device(device)))
    pre_process = transforms.Compose([transforms.ToTensor()])
else:
    model = gtsrb.GtsrbCNN(n_class=class_n_gtsrb).to(device)
    model.load_state_dict(
        # torch.load(f'ShadowAttack/model/{"adv_" if target_model == "robust" else ""}model_gtsrb.pth',
        torch.load(f'ShadowAttack/model/{"adv_" if target_model == "robust" else ""}model_gtsrb.pth',
                   map_location=torch.device(device)))
    pre_process = transforms.Compose([
        pre_process_image, transforms.ToTensor()])
model.eval()

def attack(attack_image, label, coords, targeted_attack=False, physical_attack=False, generated_images=None, **parameters):
    r"""
    Physical-world adversarial attack by shadow.

    Args:
        generated_images: images generated by diffusion model or other methods
        attack_image: The image to be attacked.
        label: The ground-truth label of attack_image.
        coords: The coordinates of the points where mask == 1.
        targeted_attack: Targeted / Non-targeted attack.
        physical_attack: Physical / digital attack.

    Returns:
        adv_img: The generated adversarial image.
        succeed: Whether the attack is successful.
        num_query: Number of queries.
    """
    num_query = 0
    succeed = False
    global_best_solution = float('inf')
    global_best_position = None

    for attempt in range(n_try):

        if succeed:
            break

        print(f"try {attempt + 1}:", end=" ")

        pso = PSO(polygon*2, particle_size, iter_num, x_min, x_max, max_speed,
                  shadow_level, attack_image, coords, model, targeted_attack,
                  physical_attack, label, pre_process, generated_images, **parameters)

        best_solution, best_pos, succeed, query = pso.update_digital() \
            if not physical_attack else pso.update_physical()

        if targeted_attack:
            best_solution = 1 - best_solution
        print(f"Best solution: {best_solution} {'succeed' if succeed else 'failed'}")
        if best_solution < global_best_solution:
            global_best_solution = best_solution
            global_best_position = best_pos
        num_query += query

    adv_image, shadow_area = draw_shadow(
        global_best_position, attack_image, coords, shadow_level)
    adv_image = shadow_edge_blur(adv_image, shadow_area, 3)

    return adv_image, succeed, num_query


def attack_digital(attack_db: str = "LISA"):
    shadow_level = 0.5  # Replace with the desired shadow level
    # position_list, mask_list = load_params()
    save_dir = f'./adv_img/{attack_db}/{int(shadow_level * 100)}'
    try:
        os.makedirs(save_dir, exist_ok=True)
    except FileExistsError:
        for name in os.listdir(save_dir):
            os.remove(os.path.join(save_dir, name))

    save_dir_bmp = os.path.join(save_dir, 'bmp')
    save_dir_png = os.path.join(save_dir, 'png')
    os.makedirs(save_dir_bmp)
    os.makedirs(save_dir_png)

    file_names, orig_imgs, cropped_imgs, cropped_resized_imgs, labels, bbx = process_image('kaggle_images', #/workspace/traffic-diffusion/
                                                            'kaggle_annotations', attack_db) #/workspace/traffic-diffusion/
    cnt_attacked = 0
    print(f"Start attacking {len(cropped_resized_imgs)} images")
    for index in range(len(cropped_resized_imgs)):
        mask_type = judge_mask_type(attack_db, labels[index])
        if brightness(cropped_resized_imgs[index], mask_list[mask_type]) >= 120:
            adv_img, success, num_query = attack(
                cropped_resized_imgs[index], labels[index], position_list[mask_type])

            cv2.imwrite(f"{save_dir_bmp}/{file_names[index]}_{labels[index]}_{num_query}_{success}.bmp", adv_img)
            cv2.imwrite(f"{save_dir_png}/{file_names[index]}_{labels[index]}_{num_query}_{success}.png", adv_img)
            cnt_attacked+=1

            # Plot one or two examples
            if cnt_attacked < 2:
                plot_triple_images_and_adv(orig_imgs[index], cropped_imgs[index], cropped_resized_imgs[index], adv_img)
        else:
            print(f"Skip index {index} because of brightness")

    print("Attack finished! Success rate: ", end='')
    print(Counter(map(lambda x: x[:-4].split('_')[-1],
                      os.listdir(save_dir)))['True'] / len(os.listdir(save_dir)))


def load_generated_augmentations(dir_path, bbx, to_size=32):
    generated_imgs = []
    for img_name in os.listdir(dir_path):
        if img_name.lower().endswith(('jpg','png')):
            # img_file_name_without_ext = img_file[:-4]
            # image_filename = img_file_name_without_ext + '.png'
            image_path = os.path.join(dir_path, img_name)
            image = cv2.imread(image_path)
            cropped_img = crop_image(image, bbx[0], bbx[1], bbx[2], bbx[3])
            cropped_resized = cv2.resize(cropped_img, (to_size, to_size))
            generated_imgs.append(cropped_resized)

    return generated_imgs

def attack_physical(attack_db):
    global position_list
    file_names, orig_imgs, cropped_imgs, cropped_resized_imgs, labels, bbx = process_image('kaggle_images',
                                                                                      # /workspace/traffic-diffusion/
                                                                                      'kaggle_annotations',
                                                                                      attack_db, crop_size=224)  # /workspace/traffic-diffusion/
    cnt_attacked = 0
    ind = file_names.index("road66")
    print(file_names[ind])

    # image_path = r'kaggle_images/road66.png'
    image = cropped_imgs[ind]
    # image_path = r'ShadowAttack/tmp/gtsrb_30.png'
    image_label = 12#14#1#12
    # mask_path = r'ShadowAttack/tmp/gtsrb_30_mask.png'
    mask_path = r'octagon_mask.png'
    size=224
    mask_image = cv2.resize(
        cv2.imread(mask_path, cv2.IMREAD_UNCHANGED), (size, size))
    mask_image = np.expand_dims(mask_image, axis=-1)
    target_image = cv2.resize(image, (size, size))
    # target_image = cv2.resize(
    #     cv2.imread(image_path), (224, 224))
    generated_dir_path = r'generated_images/road66'
    generated_imgs_cropped = load_generated_augmentations(generated_dir_path, bbx[ind], to_size=size)
    output_dir='tmp'
    os.makedirs(output_dir, exist_ok=True)
    pos_list = np.where(mask_image.sum(axis=2) > 0)

    # EOT is included in the first stage
    adv_img, _, _ = attack(target_image, image_label, pos_list,
                           physical_attack=True, transform_num=10, generated_images=generated_imgs_cropped)

    cv2.imwrite(f'./{output_dir}/temp.bmp', adv_img)
    if attack_db == 'LISA':
        predict, failed, msg = lisa.test_single_image(
            f'./{output_dir}/temp.bmp', image_label, target_model == "robust")
    else:
        predict, failed = gtsrb.test_single_image(
            f'./{output_dir}/temp.bmp', image_label, target_model == "robust")
    if failed:
        print('Attack failed! Try to run again.')

    print("part b-------------------------------------------------")
    # Predict stabilization
    adv_img, _, _ = attack(target_image, image_label, pos_list, targeted_attack=True,
                           physical_attack=True, target=predict, transform_num=10, generated_images=generated_imgs_cropped)

    cv2.imwrite(f'./{output_dir}/adv_img.png', adv_img)
    if attack_db == 'LISA':
        predict, failed, msg = lisa.test_single_image(
            f'./{output_dir}/adv_img.png', image_label, target_model == "robust")
    else:
        predict, failed = gtsrb.test_single_image(
            f'./{output_dir}/adv_img.png', image_label, target_model == "robust")
    if failed:
        summary_msg = 'Attack failed! Try to run again.'
    else:
        summary_msg = 'Attack succeed! Try to implement it in the real world.'
        print(summary_msg)

    plt.imshow(cv2.cvtColor(adv_img, cv2.COLOR_BGR2RGB))
    plt.show()
    # cv2.waitKey(0)
    with open(f'./{output_dir}/results.txt', 'w') as f:
        f.write(msg)
        f.write(summary_msg)
    print("output dir: ", output_dir)

if __name__ == "__main__":
    # Call the attack_digital() function
    # attack_db = "LISA"  # # Replace with "LISA" or "GTSRB" depending on your use case, Replace with the actual attack database
    # attack_digital(attack_db)
    attack_physical(attack_db)